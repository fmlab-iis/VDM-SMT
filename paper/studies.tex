This section gives studies that apply our encoding to selected VDM-SL models and discusses the results. All the selected VDM-SL models are from the Overture repository\footnote{a url link here}.

\subsection{Abstract Pacemaker}

This model specifies an abstract pacemaker with some core functionalities of pulse trace selection\footnote{This model was developed by Sten Agerholm et al. in 1999 in connection with FM'99}. The data types used in the model are defined as follows:
% The model is described in VDM-SL as a short, flat specification. This enables abstraction from design considerations and ensures maximum focus on high-level, precise and systematic analysis

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
  Trace = seq of [Event];
  Event = <A> | <V>;

  state Pacemaker of
    aperiod : nat 
    vdelay  : nat
  init p == p = mk_Pacemaker(15,10)
  end
\end{Verbatim}
\end{mdframed}

{\tt Trace} is of sequence type of {\tt Event}, where {\tt Event} is of quote type with two values {\tt <A>} and {\tt <V>}. The state is defined as two natural numbers with initial value of {\tt (15,10)}. In Z3, natural numbers is encoded as positive integers (integers with constraint of greater and equal to zero); quote type can be encoded as enumeration type {\tt EnumSort}; sequence type can be encoded as {\tt ArraySort}. The definitions of {\tt Event} and {\tt Trace} are as follows:

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
  Event_lift, (A, V, nil, NDF) = 
    EnumSort('Event_lift', 
            ['A', 'V', 'nil', 'NDF'])

  Trace = ArraySort(IntSort(),Event_lift)
\end{Verbatim}
\end{mdframed}

Because VDM uses partial functions, to encode as SMT formulas in Z3, we need to lift {\tt Event} to include the undefined case {\tt NDF}. Also, square brackets of {\tt [Evnet]} means the value can be {\tt nil}. Furthermore, since {\tt Trace} is defined as an array in Z3, we added constraints that limit an array as a sequence. Note that in Z3, the constraints are applied on each instance of type {\tt Trace} ({\tt tr} in the following formulas), not on the type itself.

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
  tr = Const('tr',Trace)
  [i,j] = Ints('i j')

  ForAll(i, Implies( i<=0, tr[i]==NDF ) )

  ForAll(i,
    Implies(
      And(i>=1,tr[i]!=NDF),
      ForAll(j,
        Implies(And(j>=1,j<=i),tr[j]!=NDF)
      )
    )
  )

  ForAll(i,
    Implies(
      And(i>=1,tr[i]==NDF),
      ForAll(j,
        Implies(j>=i,tr[j]==NDF)
      )
    )
  )
\end{Verbatim}
\end{mdframed}

The first constraint says that the all indexes of {\tt tr} below 1 should be undefined because in VDM-SL, a sequence's index starts from 1. The second constraint says that if an index is defined, i.e., not undefined, all indexes lower than it should be all defined. The third constraint says tat if an index is undefined, all indexes higher than it should be all undefined. From the above three constraints, we limited an array as a sequence that starts from index 1 to its last element. 

% \begin{itemize}
% \item
% A sequence's index is from 1, so indexes below 1 ($<=0$) should be all undefined.
% $\forall i \in \mathcal{Z}, i<=0. ~tr[i] = NDF $
% \item
% If an index is defined in the sequence, all indexes lower then it should be all defined.
% $\forall i \in \mathcal{Z}. ~tr[i] \neq NDF \rightarrow (\forall j \in \mathcal{Z}, 1<=j \land j <= i. ~tr[j] \neq NDF)$
% \item
% If an index is undefined, all indexes higher then it should be all undefined.
% $\forall i \in \mathcal{Z}. ~(i >= 1 \land tr[i] = NDF) \rightarrow (\forall j \in \mathcal{Z}, j >= i. ~tr[j] = NDF)$
% \end{itemize}

% where $NDF$ stands for undefined. The above formulas are added as constraints whenever the instance {\tt tr} of type {\tt Trace} is used.

Since in the VDM-SL model, the length function of a sequence is used, we also need to define the length function in Z3. Here we defined an uninterpreted function {\tt len\_tr} for {\tt tr} the instance of {\tt Trace}.
% $(len\_tr(tr) = 0 \land tr[1] = 0) \lor (len\_tr(tr) > 0 \land tr[len\_tr(tr)] \neq NDF \land tr[len\_tr(tr)+1] = NDF$

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
len_tr=Function('len_tr',Trace,IntSort())

Or(
  And(
    len_tr(tr)==0,
    tr[1]==NDF
  ),
  And(
    len_tr(tr)>0,
    tr[len_tr(tr)]!=NDF,
    tr[len_tr(tr)+1]==NDF
  )
)
\end{Verbatim}
\end{mdframed}

{\tt len\_tr} is defined as an uninterpreted function that takes {\tt tr} as input and returns an integer indicates the length of {\tt tr}. Since the length of a sequence can only be equal or greater than 0, the constraint of {\tt len\_tr} is divided into two cases:

\begin{enumerate}
\item
If {\tt len\_tr} returns 0, then {\tt tr} is an sequence with no element. That is, {\tt tr[1]} has to be undefined so that all indexes of {\tt tr} are then undefined based on previous constraints.
\item
If {\tt len\_tr} returns an integer greater than 0, then {\tt tr} has defined elements till its length index {\tt len\_tr(tr)} such that the element at and after index {\tt len\_tr(tr)+1} should be undefined.
\end{enumerate}

We have defined the context information related to type {\tt Trace}. Now we can procceed to encode and prove the POs of the model. For this VDM-SL model, Overture generated nine POs. Most of the POs are similar so we only demonstrate PO8 and PO3.

$\bullet$ PO8 is a legal sequence application obligation of operation {\tt Pace} which is explicitly specified. This PO requires that the formulas specified with trace {\tt tr} be legal, i.e., computable to get its result.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
(forall tr:Trace, aperi:nat1, vdel:nat1,
  oldstate & 
    (forall i in set (inds (tl tr)) &
      (((i mod aperi) = (vdel + 1)) =>
        (i in set (inds tr)))
))
\end{Verbatim}
\end{mdframed}

In PO8 showed above, {\tt tl tr} is the tail of {\tt tr}, and {\tt inds} is the operator of gathering indexes of defined elements of {\tt tr} as the set of natural numbers. To prove PO8, firstly we took negation of PO8 which results a quantifier eliminated formula.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
Exists tr:Trace, aperi:nat1, vdel:nat1 &
  (Exists i in set (inds (tl tr)) &
     Not(
      ((i mod aperi) = (vdel + 1)) =>
       (i in set (inds tr))
     )
  )
\end{Verbatim}
\end{mdframed}

Note that the {\tt oldstate} is not used in the operation so that we remove it in the above formula. To encode the PO in Z3, the PO can be recognized as the formula $\exists~[tr:Trace,aperi:nat1,vdel:nat1,i:nat] P \land Q \land \neg R$ where $P$, $Q$, and $\neg R$ can be encoded separately.

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
  And(aperi>=1,vdel>=1)        #nat1
  And(i>=1, i<=len_tr(tr)-1)   #P
  i%aperi==vdel+1              #Q
  Not(And(i>=1,i<=len_tr(tr))) #not R
\end{Verbatim}
\end{mdframed}

In the encoding of $P$, the tail related formula can be encoded as in the range of $[1,(len~tr)-1]$ so that it is not required to define {\tt tl} and {\tt inds} for sequences. Finally, we checked the satisfiability of the encoded Z3 code and got {\tt unsat}, which means that the PO is proved since we have negated it.


% {\tt Periodic}: legal sequence application obligation\\
% This PO is meant to represent the applicability of statements used in the function {\tt Periodic}, that is, the expressions in {\tt Periodic} are computable to get a result. The formula of the PO is in the form of 
% $\forall tr,e,p. ~\forall t \in inds ~tr. ~(~P \rightarrow ~(~Q \rightarrow ~(~R \rightarrow ~(~S \rightarrow ~(~\forall i. ~T \rightarrow U~)~)~)~)$. where 
% \begin{itemize}
% \item
% $tr: Trace$;~$e:Event$;~$p:nat1$;~$t:nat$
% \item
% $P = t \in set~(inds~tr)$
% \item
% $Q = (tr(t)=e)$
% \item
% $R = (t+p) ~<=~ (len~tr)$
% \item
% $S = (tr((t+p))=e) ~\land~ \forall i \in \{(t+1, \ldots, (t+p)-1\}. ~tr(i) \neq e )$
% \item
% $T = ((t+p) > (len~tr)~)$
% \item
% $U = (\forall i \in \{(t+1), \ldots, len~tr \}. ~i \in set (inds~tr)$
% \end{itemize}


% After taken negation of the formula, we got 
% $\exists tr,e,p,t,i. ~(P \land Q \land Q \land S \land T \land \neg U~)$. In the negated case, the expected result of the negated PO is unsatisfiable, i.e., unsat. The


$\bullet$ PO3 is the postcondition satisfiable obligation of the implicitly specified operation {\tt FaultHeart} that generates a trace of heart pulse signals. PO3 says that the postcondition of {\tt FaultHeart} has to be satisfiable so that the specification of {\tt FaultHeart} is implementable.

% \medskip
\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
exists tr:Trace &
  post_FaultyHeart(oldstate, tr, newstate)

FaultyHeart() tr : Trace
post len tr = 100 and
  Periodic(tr,<A>,aperiod) and 
  not Periodic(tr,<V>,aperiod);
\end{Verbatim}
\end{mdframed}
% \medskip

The above VDM-SL code also shows that definition of {\tt FaultyHeart}. Recall that the state is defined as a pair of natural numbers {\tt aperiod} and {\tt vdelay}. The postcondition of {\tt FaultyHeart} is not specified with {\tt oldstate} which has suffixed tilde, i.e, {\tt aperiod\textasciitilde} and {\tt vdelay\textasciitilde}. Therefore, PO3 is a simplified postcondition satisfiable obligation saying that there exists a {\tt Trace} {\tt tr} which satisfies the postcondition specified with only {\tt newstate}\footnote{How the {\tt newstate} is calculated from {\tt oldstate} is not specified in {\tt FaltyHeart}.}. The postcondition uses the function {\tt Periodic} which is explicitly specified and returns a boolean value. We need to encode {\tt Periodic} as well to prove PO3.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
Periodic: Trace * Event * nat1 -> bool
Periodic(tr,e,p) ==
  forall t in set inds tr &
   (tr(t) = e) =>
   (t + p <= len tr =>
   ((tr(t+p) = e and
     forall i in set {t+1, ..., t+p-1} &
       tr(i) <> e)) and
    (t + p > len tr =>
     forall i in set {t+1, ..., len tr} &
       tr(i) <> e));
\end{Verbatim}
\end{mdframed}

While the specification of {\tt Periodic} is relatively long. The encoding of {\tt Periodic} is similar to the encoding of PO8. We may observe some similar computations on the trace {\tt tr} such as {\tt in set inds tr} and {\tt len tr}, and we can encode them in the same way as handling PO8. Note that we did not apply negation to the formula since existence quantifier in the prefix of a formula is preferred in Z3. As a result, we got a result of {\tt sat} so that PO3 is proved.

The results of all nine POs of the Abstracted Pacemaker VDM-SL model is showed in Table~\ref{tbl:result1} with information of whether negation is applied, and the time used.

\begin{table}[htb]
\begin{center}
\begin{tabular}{|c|c|r|r|}
\hline
PO\#	&	negated?	&	result	&	time (sec.) \\ \hline
1		&	Y			&	sat		&	0.031 \\ \hline
2		&	Y			&	unsat	&	0.031 \\ \hline
3		&	N			&	sat		&	15.109 \\ \hline
4		&	Y			&	unsat	&	0.032 \\ \hline
5		&	Y			&	unsat	&	0.046 \\ \hline
6		&	Y			&	unsat	&	0.048 \\ \hline
7		&	Y			&	unsat	&	0.062 \\ \hline
8		&	Y			&	unsat	&	0.031 \\ \hline
9		&	Y			&	sat		&	0.047 \\ \hline
\end{tabular}
\end{center}
\caption{Absract Pacemaker Result}
\label{tbl:result1}
\end{table}


\subsection{Telephone Exchange}

This model specifies an abstracted telephone exchange system. In this model, the operations specify the events which can be initiated either by the system or by a subscriber (user) with implicit style. The system state monitors the calling status of users and the connecting status among users. Type in the model are based on quote types used to indicate the discrete states of users, then maps are specified to relate the calling and connecting status to users as the system state. An invariant is specified for the state {\tt Exchange} to declare the constraints among users and their status in the system.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
Subscriber = token;
Initiator =  <AI> | <WI> | <SI>;
Recipient = <WR> | <SR>;
Status = <fr> | <un> |
         Initiator | Recipient;
                                                                      
state Exchange of
  status: map Subscriber to Status
  calls:  inmap Subscriber to Subscriber
inv mk_Exchange(status, calls) == 
  forall i in set dom calls & 
    (status(i) = <WI> and
     status(calls(i)) = <WR>) or
    (status(i) = <SI> and
     status(calls(i)) = <SR>)
init s == s = mk_Exchange({|->},{|->})
end
\end{Verbatim}
\end{mdframed}

The strategy of encoding the above types is (1) applying user-defined types in Z3 to encode the quote types; (2) applying uninterpreted functions to encode map type. Here we only demonstrate a few selected types since the others are similar. 

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
Recipient = Datatype('Recipient')
Recipient.declare('WR')
Recipient.declare('SR')
Recipient = Recipient.create()

Status = Datatype('Status')
Status.declare('fr')
Status.declare('un')
Status.declare('INITIATOR',
               ('get_initiator', Initiator))
Status.declare('RECIPIENT',
               ('get_recipient', Recipient))
Status = Status.create()

Status_lift = Datatype('Status_lift')
Status_lift.declare('STATUS',
                    ('get_status', Status))
Status_lift.declare('NDF')
Status_lift = Status_lift.create()

status = Function('status',
                  Subscriber,Status_lift)
calls = Function('calls',
                 Subscriber,Subscriber_lift)
\end{Verbatim}
\end{mdframed}

From above code, the type {\tt Recipient} is defined as an user-defined type with values {\tt WR} and {\tt SR}. Type {\tt Status} is further defined as a user-defined type including {\tt Recipient} and {\tt Initiator}. Note that since VDM uses partial functions, we also defined a lifted type of {\tt Status}. Though {\tt Subscriber} is of token type which does not have specific values when declared, we treated token types as quote types with predefined values such as {\tt S1}, {\tt S2}, and so on. Finally the two maps {\tt status} and {\tt calls} are defined as uninterpreted functions. Overture generated 27 POs for this model. Here we present the encoding and proving of PO1 and PO14.

$\bullet$ PO1 is a legal map application obligation that checks whether maps in the system state are applicable. 

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
forall
  mk_Exchange(status, calls):EXCH`Exchange &
    (forall i in set (dom calls) &
      (i in set (dom status))
    )
)
\end{Verbatim}
\end{mdframed}

Since PO1 explicitly uses the system state, we need to consider the invariant of the system state as the context information of PO1. 
Instead of demonstrate the full encoding of the invariant, we only demonstrate the key encoding for {\tt i in set (dom calls)} and {\tt i in set (dom status)}. Though there is set inclusion used, instead of defining a set, we can encode the set inclusion as whether {\tt calls(i)} is defined or not.

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
  calls(i) != Subscriber_lift.NDF
  status(i)!= Status_lift.NDF
\end{Verbatim}
\end{mdframed}

For PO1, we applied negation to the formula so that the {\tt forall} quantifier for maps {\tt calls} and {\tt status} is removed. The result was {\tt unsat} which means PO1 was proved.

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
Not(
  ForAll(i,
    Implies(
      calls(i)!=Subscriber_lift.NDF,
      status(i)!=Status_lift.NDF
    )
  )
)
\end{Verbatim}
\end{mdframed}

$\bullet$ PO14 is an enumeration map injectivity obligatoin of the operation {\tt Answer} of the system. PO14 has free variables, {\tt r} and {\tt status}, in its formula. These free variables are treated as the quantifier {\tt forall} is prefixed. There are also intermediate variables in the formula such as {\tt m1}, {\tt m2}, {\tt d3}, and {\tt d4}. Note that the inverse function of a map, and the range restriction function {\tt :>} are {\tt applied} on calls and {\tt status}. Also note that {\tt calls} is a one-to-one map {\tt inmap}.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
(r in set (dom (status :> {<WR>}))) =>
  (forall m1, m2 in 
    set {{r |-> <SR>}, 
         {(inverse calls)(r) |-> <SI>}} &
    (forall d3 in set (dom m1),
            d4 in set (dom m2) &
      ((d3 = d4) => (m1(d3) = m2(d4)))
))
\end{Verbatim}
\end{mdframed}

We negated PO14 so that the {\tt forall} quantifiers are removed. To encode the negated formula of PO14, similar technique for  encoding {\tt set (dom status)} for PO1 can be applied. For the range restriction function, since the range is a single set with value {\tt <WR>}, there is no need of applying set notations but limiting the map value {\tt status(r)} to {\tt <WR>}. Thus, {\tt r in set (dom (status :> \{<WR>\}))} is encoded as follows.

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
status(r)==
  Status_lift.STATUS(
    Status.RECIPIENT(Recipient.WR) )
\end{Verbatim}
\end{mdframed}

For the map inverse function, we encoded {\tt m1 = \{(inverse calls)(r) |-> <SI>\}} as multiple conditions: (1) the part of map, where key {\tt i} is used and inverse is applied, should be defined; (2) the inversed domain, i.e., the range of original map, is {\tt r}; (3) then {\tt m1(i)} is {\tt <SI>}; (4) for all other indexes, {\tt m1} should be undefined.

\begin{mdframed}[roundcorner=5pt,shadow=true]
\begin{Verbatim}[fontsize=\small]
# inverse map is not empty
calls(i)!=Subscriber_lift.NDF 
# inverse_calls(r) == i
Subscriber_lift.get_subscriber(calls(i))==r

m1(i)==Status_lift.STATUS(
         Status.INITIATOR(Initiator.SI)),
ForAll(k, 
  Implies(k!=i, m1(k)==Status_lift.NDF) )
\end{Verbatim}
\end{mdframed}

The result of checking PO14 ware expected to be {\tt unsat} but we got {\tt sat} and a model that satisfies the formula and constraints. 


\subsection{Discussion}

Overture generated 27 POs for this model. These POs can be divided into several groups as showed below. In this case study we encoded and checked the first three groups using the above encoding of types. The reason of not handling the postcondition obligations is that the maps defined using uninterpreted functions cannot be used together with quantifiers. Also, map inverse obligations have {\tt is\_(name, type)}, the function of type check provided by VDM, in their formulas. There is no appropriate encoding for such type check functions in Z3. 

\begin{enumerate}
\item
Legal map application obligations, invariant satisfiable obligations: 1 to 7.
\item
Enumeration map injectivity obligations: 9, 14, 18, 21, 25.
\item
Legal map application obligations with inverse map: 12, 17, 20, 23.
\item
Operation postcondition satisfiable obligations: 8, 10, 11, 15, 16, 19, 22, 26, 27
\item
Map inverse obligations: 13, 24.
\end{enumerate}

