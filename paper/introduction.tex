% General information about VDM
The Vienna Development Method (VDM)~\cite{Jones:1990:SSD:94062,Fitzgerald:2005:VDO:1044891,Fitz:PGLarson:2009book} is a formal method which supports modeling and analysis of software systems at various levels of abstraction. A VDM specification, i.e. software specifications described in a VDM model, uses a combination of implicit and/or explicit definitions of functionalities to describe software specifications acquired from software requirements. VDM has a strong record of applications for design and specification of software systems in industry~\cite{Larsen:2007:RIA:2227886.2227894,DBLP:conf/fm/KuritaCN08,DBLP:journals/ijsi/KuritaN09}. The well-known basic benefits of using VDM to describe software specifications are from the accuracy and unambiguity of VDM, which is common for other formal methods like B. 

% Validation methods of VDM
To validate a VDM model, existing tools such as Overture~\cite{Larsen:2010:OII:1668862.1668864} and VDMTools provide static consistency check regarding the syntax and type constraints of VDM specifications. The semantic validation of VDM specifications are rely on proof obligations (POs)~\cite{AL:97:POGV} generated by the above tools, and theorem provers are applied to discharge the generated POs. Testing (specification animation) by running a VDM model with an interpreter~\cite{Prehn:1991:LNCS551} is the alternative way of validation. This requires that the VDM model to be specified explicitly so that an interpreter can produce specific values for functions and operations.

% More about proof obligations and the motivation: solve as many as possible POs
Discharging POs of VDM models is essential to guarantee the consistency of the formal specifications. For a VDM model, the number of POs is usually large compare to the size of the model. For example, the sample VDM-SL model shown in Fig.~\ref{fig:module_sample} has less than thirty lines, and Overture generates nine POs for the model. In this paper, we propose an approach to discharging the POs of VDM specifications using SMT solvers. Here we focus on VDM-SL models and the objective is to discharge POs of an VDM-SL model as many as possible through SMT solvers. In this approach, we encode each POs whith its context information such type and state constraints, then release the encoded formulas to prove the PO. The advantages of our approach are (1) the encoding involves only a few segments of a VDM specification; (2) the proof process is automated with SMT solvers; (3) If a PO's proof fails, a counterexample model is returned for further examination. 

More specifically, in this approach we encode and prove POs of VDM-SL models as solving SMT formulas with Python API of Z3~\cite{MB:08:ZSS}. Z3 is one of the popular SMT solvers widely used in software verification and its Python API provides flexibility in building SMT formulas than using pure SMT-LIB~\cite{BarFT-SMTLIB}. We have conducted some case studies and the results showed that our approach can efficiently discharge the significant part of POs of a VDM-SL model. We chose the Overture tool as the PO generator in this paper\footnote{POs generated by Overture and VDMTools are slightly different in the numbers and styles of POs}.

The structure of this paper is as follows: Section~\ref{section:vdm} briefly introduce VDM with a sample VDM-SL example; Section~\ref{section:proof-obligations} describes the POs of VDM and explains the POs generated by the Overture tool; section~\ref{section:encode-strategy} describes our strategy of encoding VDM expressions with Python API of Z3; section~\ref{section:case-studies} demonstrates case studies with discussions; section~\ref{section:related-work} compares our approach to related work; section~\ref{section:conclusions} concludes this paper and points out the future work.

% Main story: To validate VDM models, discharging POs is the major way. However, the POs of a VDM model may rise to hundreds [give an example LOC of model vs. number of POs]. Because of undecidability of VDM POs, discharging all POs is very difficult. Our approach aims to release POs as many as possible by introducing SMT solvers. We chose Z3 because it is one of the most popular SMT solver. The Python API is handy for flexible encoding. The results are good.