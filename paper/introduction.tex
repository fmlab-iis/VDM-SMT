% General information about VDM
The Vienna Development Method (VDM)~\cite{Jones:1990:SSD:94062,Fitzgerald:2005:VDO:1044891,Fitz:PGLarson:2009book} is a formal method which supports modeling and analysis of software systems at various levels of abstraction. A VDM specification can be explicit, implicit, or both. An explicit specification is operational; it describes \emph{how} system components work. An implicit specificiation on the other hand is declarative; it describes \emph{what} system components should work. Software specifications in VDM models define functionalities explicitly or implicitly according to software requirements. VDM has a strong record of applications for design and specification of software systems in industry~\cite{Larsen:2007:RIA:2227886.2227894,DBLP:conf/fm/KuritaCN08,DBLP:journals/ijsi/KuritaN09}. The well-known basic benefits of using VDM to describe software specifications are from the accuracy and unambiguity of VDM, which is common for other formal methods like B. 

% Validation methods of VDM
To validate a VDM model, existing tools such as Overture~\cite{Larsen:2010:OII:1668862.1668864} and VDMTools provide static consistency check regarding the syntax and type constraints of VDM specifications. The semantic validation of VDM specifications are established by discharging proof obligations (POs)~\cite{AL:97:POGV} generated by the above tools. POs are logic formulas characterizing consistency of VDM specifications. Theorem provers have been used to discharge the generated POs. Testing (specification animation) by running a VDM model with an interpreter~\cite{Prehn:1991:LNCS551} is the alternative way of validation. This requires that the VDM model to be specified explicitly so that an interpreter can produce specific values for functions and operations.

% More about proof obligations and the motivation: solve as many as possible POs
Discharging POs of VDM models is essential to guarantee the consistency of the formal specifications. For a VDM model, the number of POs is usually large compare to the size of the model. For example, the sample VDM-SL model shown in Fig.~\ref{fig:module_sample} has less than thirty lines, and Overture generates nine POs for the model. Consequently, it is not uncommon to have hundreds of POs for large VDM models. All of them have to be discharged to guarantee consistency of software specifications. Manually discharging so many POs with theorem provers however can be a daunting task in practice. Furthermore, both errorneous VDM specifications and bad proof strategies induce un-dischargeable POs. Theorem provers provide little information when they fail to discharge POs. It is unclear whether a VDM specification is flawed or a better proof strategy is possible when POs cannot be discharged by theorem provers.

% SMT
Satisfiability Modulo Theories (SMT) solvers extend SAT solvers by incorporating decision procedures for first-order theories such as linear arithmetic. Given a quantifier-free first-order logic formula in mixed theories, SMT solvers will try to find a model satisfying the given formula or report that the formula is unsatisfiable. Thanks to their efficiency, SMT solvers have found a wide range of applications from software verification to software testing. Recent SMT solvers can even check satisfiability of general first-order formulas. It is therefore interesting to see if one can take advantages of recent developments of SMT solvers to discharge first-order POs in VDM models. 

%Of course, the complexity of deciding satisfiability of general first-order formulas increases drastically even for decidable theories. Modern SMT solvers have to employ sophisticated heuristics to improve efficiency in practice. 

In this paper, we apply SMT solvers to discharge POs of VDM specifications. Here we focus on VDM-SL models and the objective is to discharge POs of an VDM-SL model as many as possible through SMT solvers. In our approach, we encode each POs with its context information such as type and state constraints as a first-order formula, and then prove the PO by sending the formula to SMT solvers. The advantages of our approach are (1) the encoding involves only a few segments of a VDM specification; (2) the proof process is automated with SMT solvers; (3) If a PO's proof fails, a counterexample model is returned for further examination. 

More specifically, in this approach we encode and prove POs of VDM-SL models by solving SMT formulas with Python API of Z3~\cite{MB:08:ZSS}. Z3 is a popular SMT solver widely used in software verification and its Python API provides flexibility in constructing SMT formulas~\cite{BarFT-SMTLIB}. In order to encode POs, built-in VDM types such as sequences and maps must be characterized by theories in Z3. We conducted case studies and the results showed that our approach can efficiently discharge the significant part of POs of a VDM-SL model. We chose the Overture tool as the PO generator in this paper\footnote{POs generated by Overture and VDMTools are slightly different in the numbers and styles of POs}.

The structure of this paper is as follows: Section~\ref{section:vdm} briefly introduce VDM with a sample VDM-SL example; Section~\ref{section:proof-obligations} describes the POs of VDM and explains the POs generated by the Overture tool; section~\ref{section:encode-strategy} describes our strategy of encoding VDM expressions with Python API of Z3; section~\ref{section:case-studies} demonstrates case studies with discussions; section~\ref{section:related-work} compares our approach to related work; section~\ref{section:conclusions} concludes this paper and points out the future work.

% Main story: To validate VDM models, discharging POs is the major way. However, the POs of a VDM model may rise to hundreds [give an example LOC of model vs. number of POs]. Because of undecidability of VDM POs, discharging all POs is very difficult. Our approach aims to release POs as many as possible by introducing SMT solvers. We chose Z3 because it is one of the most popular SMT solver. The Python API is handy for flexible encoding. The results are good.