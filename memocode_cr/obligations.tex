% Objective: explain the semantics of Overture generated POs.
% Explain what is proof obligation in VDM. There are kinds of POs: domain, subtype, satisfiability, and termination. Any example?
% Explain POs generated by the Overture tool. Any example?

% Generation information of POs
For a VDM model, a proof obligation (PO) is a statement that must be proved to ensure the consistency of the model. A PO contains a predicate with its context information as shown below. The context information is from code segments of the VDM model that relates to the predicate to be proved.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
PO: context information ==> predicate
\end{Verbatim}
\end{mdframed}

% Classifications of POs and sample POs from sample VDM-SL model
POs of VDM-SL can be classified type compatibility (subtype checking), domain checking, and satisfiability~\cite{AL:97:POGV,Vermolen:2010:PCV:1774088.1774608}. Type compatibility relates to types with invariant or subtypes; domain checking relates to the use of partial functions and partial operators; satisfiability relates postconditions of functions and operations. 

% Example VDM-SL segment and corresponding POs with explanation
Below is a segment of VDM-SL model and two of the corresponding POs generated by the Overture tool. The VDM-SL specification is a state definition which consists of a sequence of commands {\tt <R>} or {\tt <L>} or {\tt nil}. The state invariant says that for every element of {\tt commands}, its next element must be assigned different value. PO1 is a state invariant satisfiable obligation which is a subtype checking for confirming that there exist values of state {\tt S} satisfying the state invariant. PO2 is a legal sequence application obligation which is a domain checking for confirming that in the state invariant, {\tt (s.commands)(k)}, the k-th element of {\tt commands} has to be defined. Though looked obvious, this kind of POs is important for VDM because of the use of partial functions in VDM.

\begin{mdframed}[roundcorner=5pt]
\begin{Verbatim}[fontsize=\small]
-- //spec. segment
state S of
  commands : seq of [<R> | <L>]
  inv s == forall k in set 
    {1,...,len s.commands - 1} &
    s.commands(k) <> s.commands(k+1)
  init p == p = mk_S([])
end

-- //PO1: state invariant satisfiable obligation
-- //     (subtype check)
(exists commands:seq of [<R> | <L>] &
  (forall k in set {1, ... ,((len (s.commands)) - 1)} &
    ((s.commands)(k) <> (s.commands)((k + 1)))
))

-- //PO2: legal sequence application obligation
-- //    (domain check)
(forall s:CMDS`S & 
  (forall k in set 
    {1, ... ,((len (s.commands)) - 1)} & 
    (k in set (inds (s.commands)))))
\end{Verbatim}
\end{mdframed}
